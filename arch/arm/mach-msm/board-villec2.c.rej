--- arch/arm/mach-msm/board-villec2.c
+++ arch/arm/mach-msm/board-villec2.c
@@ -3263,14 +3264,56 @@
 };
 
 #ifdef CONFIG_SERIAL_MSM_HS
+static int configure_uart_gpios(int on)
+{
+	int ret = 0, i;
+	int uart_gpios[] = {
+		VILLEC2_GPIO_BT_UART1_TX,
+		VILLEC2_GPIO_BT_UART1_RX,
+		VILLEC2_GPIO_BT_UART1_CTS,
+		VILLEC2_GPIO_BT_UART1_RTS,
+	};
+	for (i = 0; i < ARRAY_SIZE(uart_gpios); i++) {
+		if (on) {
+			ret = msm_gpiomux_get(uart_gpios[i]);
+			if (unlikely(ret))
+				break;
+		} else {
+			ret = msm_gpiomux_put(uart_gpios[i]);
+			if (unlikely(ret))
+				return ret;
+		}
+	}
+	if (ret)
+		for (; i >= 0; i--)
+			msm_gpiomux_put(uart_gpios[i]);
+	return ret;
+}
+
 static struct msm_serial_hs_platform_data msm_uart_dm1_pdata = {
+	.wakeup_irq = -1,
 	.inject_rx_on_wakeup = 0,
-	.cpu_lock_supported = 1,
+	.gpio_config = configure_uart_gpios,
+#ifdef CONFIG_SERIAL_BCM_BT_LPM
+	.exit_lpm_cb = bcm_bt_lpm_exit_lpm_locked,
+#endif
+};
 
-	/* for bcm BT */
-	.bt_wakeup_pin_supported = 1,
-	.bt_wakeup_pin = VILLEC2_GPIO_BT_CHIP_WAKE,
-	.host_wakeup_pin = VILLEC2_GPIO_BT_HOST_WAKE,
+static struct bcm_bt_lpm_platform_data bcm_bt_lpm_pdata = {
+	.gpio_wake = VILLEC2_GPIO_BT_CHIP_WAKE,
+	.gpio_host_wake = VILLEC2_GPIO_BT_HOST_WAKE,
+#ifdef CONFIG_SERIAL_BCM_BT_LPM
+	.request_clock_off_locked = msm_hs_request_clock_off_locked,
+	.request_clock_on_locked = msm_hs_request_clock_on_locked,
+#endif
+};
+
+struct platform_device villec2_bcm_bt_lpm_device = {
+	.name = "bcm_bt_lpm",
+	.id = 0,
+	.dev = {
+		.platform_data = &bcm_bt_lpm_pdata,
+	},
 };
 #endif
 
@@ -6207,8 +6251,6 @@
 #endif
 
 #ifdef CONFIG_SERIAL_MSM_HS
-	msm_uart_dm1_pdata.rx_wakeup_irq = gpio_to_irq(VILLEC2_GPIO_BT_HOST_WAKE);
-	msm_device_uart_dm1.name = "msm_serial_hs_brcm";
 	msm_device_uart_dm1.dev.platform_data = &msm_uart_dm1_pdata;
 #endif
 
