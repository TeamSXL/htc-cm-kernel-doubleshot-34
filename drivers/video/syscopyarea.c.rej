--- drivers/video/syscopyarea.c
+++ drivers/video/syscopyarea.c
@@ -20,6 +20,9 @@
 #include <asm/io.h>
 #include "fb_draw.h"
 
+    /*
+     *  Generic bitwise copy algorithm
+     */
 
 static void
 bitcpy(struct fb_info *p, unsigned long *dst, int dst_idx,
@@ -33,15 +36,15 @@
 	last = ~(FB_SHIFT_HIGH(p, ~0UL, (dst_idx+n) % bits));
 
 	if (!shift) {
-		
+		/* Same alignment for source and dest */
 		if (dst_idx+n <= bits) {
-			
+			/* Single word */
 			if (last)
 				first &= last;
 			*dst = comp(*src, *dst, first);
 		} else {
-			
-			
+			/* Multiple destination words */
+			/* Leading bits */
  			if (first != ~0UL) {
 				*dst = comp(*src, *dst, first);
 				dst++;
@@ -49,7 +52,7 @@
 				n -= bits - dst_idx;
 			}
 
-			
+			/* Main chunk */
 			n /= bits;
 			while (n >= 8) {
 				*dst++ = *src++;
@@ -65,7 +68,7 @@
 			while (n--)
 				*dst++ = *src++;
 
-			
+			/* Trailing bits */
 			if (last)
 				*dst = comp(*src, *dst, last);
 		}
@@ -73,38 +76,44 @@
 		unsigned long d0, d1;
 		int m;
 
-		
+		/* Different alignment for source and dest */
 		right = shift & (bits - 1);
 		left = -shift & (bits - 1);
 
 		if (dst_idx+n <= bits) {
-			
+			/* Single destination word */
 			if (last)
 				first &= last;
 			if (shift > 0) {
-				
+				/* Single source word */
 				*dst = comp(*src >> right, *dst, first);
 			} else if (src_idx+n <= bits) {
-				
+				/* Single source word */
 				*dst = comp(*src << left, *dst, first);
 			} else {
-				
+				/* 2 source words */
 				d0 = *src++;
 				d1 = *src;
 				*dst = comp(d0 << left | d1 >> right, *dst,
 					    first);
 			}
 		} else {
-			
+			/* Multiple destination words */
+			/** We must always remember the last value read,
+			    because in case SRC and DST overlap bitwise (e.g.
+			    when moving just one pixel in 1bpp), we always
+			    collect one full long for DST and that might
+			    overlap with the current long from SRC. We store
+			    this value in 'd0'. */
 			d0 = *src++;
-			
+			/* Leading bits */
 			if (shift > 0) {
-				
+				/* Single source word */
 				*dst = comp(d0 >> right, *dst, first);
 				dst++;
 				n -= bits - dst_idx;
 			} else {
-				
+				/* 2 source words */
 				d1 = *src++;
 				*dst = comp(d0 << left | *dst >> right, *dst, first);
 				d0 = d1;
@@ -112,7 +121,7 @@
 				n -= bits - dst_idx;
 			}
 
-			
+			/* Main chunk */
 			m = n % bits;
 			n /= bits;
 			while (n >= 4) {
@@ -136,13 +145,13 @@
 				d0 = d1;
 			}
 
-			
+			/* Trailing bits */
 			if (last) {
 				if (m <= right) {
-					
+					/* Single source word */
 					*dst = comp(d0 << left, *dst, last);
 				} else {
-					
+					/* 2 source words */
  					d1 = *src;
 					*dst = comp(d0 << left | d1 >> right,
 						    *dst, last);
@@ -152,6 +161,9 @@
 	}
 }
 
+    /*
+     *  Generic bitwise copy algorithm, operating backward
+     */
 
 static void
 bitcpy_rev(struct fb_info *p, unsigned long *dst, int dst_idx,
@@ -177,16 +189,16 @@
 	last = ~(FB_SHIFT_LOW(p, ~0UL, bits - 1 - ((dst_idx-n) % bits)));
 
 	if (!shift) {
-		
+		/* Same alignment for source and dest */
 		if ((unsigned long)dst_idx+1 >= n) {
-			
+			/* Single word */
 			if (last)
 				first &= last;
 			*dst = comp(*src, *dst, first);
 		} else {
-			
+			/* Multiple destination words */
 
-			
+			/* Leading bits */
 			if (first != ~0UL) {
 				*dst = comp(*src, *dst, first);
 				dst--;
@@ -194,7 +206,7 @@
 				n -= dst_idx+1;
 			}
 
-			
+			/* Main chunk */
 			n /= bits;
 			while (n >= 8) {
 				*dst-- = *src--;
@@ -209,43 +221,49 @@
 			}
 			while (n--)
 				*dst-- = *src--;
-			
+			/* Trailing bits */
 			if (last)
 				*dst = comp(*src, *dst, last);
 		}
 	} else {
-		
+		/* Different alignment for source and dest */
 
 		int const left = -shift & (bits-1);
 		int const right = shift & (bits-1);
 
 		if ((unsigned long)dst_idx+1 >= n) {
-			
+			/* Single destination word */
 			if (last)
 				first &= last;
 			if (shift < 0) {
-				
+				/* Single source word */
 				*dst = comp(*src << left, *dst, first);
 			} else if (1+(unsigned long)src_idx >= n) {
-				
+				/* Single source word */
 				*dst = comp(*src >> right, *dst, first);
 			} else {
-				
+				/* 2 source words */
 				*dst = comp(*src >> right | *(src-1) << left,
 					    *dst, first);
 			}
 		} else {
-			
+			/* Multiple destination words */
+			/** We must always remember the last value read,
+			    because in case SRC and DST overlap bitwise (e.g.
+			    when moving just one pixel in 1bpp), we always
+			    collect one full long for DST and that might
+			    overlap with the current long from SRC. We store
+			    this value in 'd0'. */
 			unsigned long d0, d1;
 			int m;
 
 			d0 = *src--;
-			
+			/* Leading bits */
 			if (shift < 0) {
-				
+				/* Single source word */
 				*dst = comp(d0 << left, *dst, first);
 			} else {
-				
+				/* 2 source words */
 				d1 = *src--;
 				*dst = comp(d0 >> right | d1 << left, *dst,
 					    first);
@@ -254,7 +272,7 @@
 			dst--;
 			n -= dst_idx+1;
 
-			
+			/* Main chunk */
 			m = n % bits;
 			n /= bits;
 			while (n >= 4) {
@@ -278,13 +296,13 @@
 				d0 = d1;
 			}
 
-			
+			/* Trailing bits */
 			if (last) {
 				if (m <= left) {
-					
+					/* Single source word */
 					*dst = comp(d0 >> right, *dst, last);
 				} else {
-					
+					/* 2 source words */
 					d1 = *src;
 					*dst = comp(d0 >> right | d1 << left,
 						    *dst, last);
@@ -306,16 +324,20 @@
 	if (p->state != FBINFO_STATE_RUNNING)
 		return;
 
+	/* if the beginning of the target area might overlap with the end of
+	the source area, be have to copy the area reverse. */
 	if ((dy == sy && dx > sx) || (dy > sy)) {
 		dy += height;
 		sy += height;
 		rev_copy = 1;
 	}
 
+	/* split the base of the framebuffer into a long-aligned address and
+	   the index of the first bit */
 	dst = src = (unsigned long *)((unsigned long)p->screen_base &
 				      ~(bytes-1));
 	dst_idx = src_idx = 8*((unsigned long)p->screen_base & (bytes-1));
-	
+	/* add offset of source and target area */
 	dst_idx += dy*bits_per_line + dx*p->var.bits_per_pixel;
 	src_idx += sy*bits_per_line + sx*p->var.bits_per_pixel;
 
